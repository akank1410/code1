class Solution {
public:
    
class UnionFind {
    vector<int> root;
    vector<int> rank;
public:
    UnionFind(int sz) : root(sz),rank(sz) {
        for (int i = 0; i < sz; i++) {
            { root[i] = i;
            rank[i] = 1;}
        }
    }

    int find(int x) 
    {
        while (x != root[x])
         x = root[x];
         
        return x;
    }

    void unionSet(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rank[rootX] > rank[rootY]) 
            root[rootY] = rootX;
        else if(rank[rootX] < rank[rootY])
            root[rootX] = rootY;
        else
        {
            root[rootX] = rootY;
            rank[rootY] += 1;
        }
    }
    
    /*
        void unionSet(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) 
              root[rootY] = rootX;
        }
    }*/

    bool connected(int x, int y) 
    {
        return find(x) == find(y);
    }

     int uni ()
    {
                int c=0;
                for(int i=0; i<root.size(); i++)
                {
                    if(root[i] == i )
                    c++;
                }
                return c;
     }
};
    
    
    int findCircleNum(vector<vector<int>>& isConnected) {
        
        
        int size = isConnected.size();
        UnionFind uf(size);

        for(int i=0; i<size; i++)
        {
            for(int j=0; j<size; j++)
            {
                if(isConnected[i][j] == 1)
                    uf.unionSet(i,j);
            }
        }       
        return uf.uni();

    }
};
